<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Updating Objects in State - React 18 Docs</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Get Started</li><li class="chapter-item expanded "><a href="../learn/index.html"><strong aria-hidden="true">1.</strong> Quick Start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../learn/tutorial-tic-tac-toe.html"><strong aria-hidden="true">1.1.</strong> Tutorial: Tic-Tac-Toe</a></li><li class="chapter-item expanded "><a href="../learn/thinking-in-react.html"><strong aria-hidden="true">1.2.</strong> Thinking in React</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Learn React</li><li class="chapter-item expanded "><a href="../learn/describing-the-ui.html"><strong aria-hidden="true">2.</strong> Describing the UI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../learn/your-first-component.html"><strong aria-hidden="true">2.1.</strong> Your First Component</a></li><li class="chapter-item expanded "><a href="../learn/importing-and-exporting-components.html"><strong aria-hidden="true">2.2.</strong> Importing and Exporting Components</a></li><li class="chapter-item expanded "><a href="../learn/writing-markup-with-jsx.html"><strong aria-hidden="true">2.3.</strong> WritiPng Markup with JSX</a></li><li class="chapter-item expanded "><a href="../learn/javascript-in-jsx-with-curly-braces.html"><strong aria-hidden="true">2.4.</strong> JavaScript in JSX with Curly Braces</a></li><li class="chapter-item expanded "><a href="../learn/passing-props-to-a-component.html"><strong aria-hidden="true">2.5.</strong> Passing Props to a Component</a></li><li class="chapter-item expanded "><a href="../learn/conditional-rendering.html"><strong aria-hidden="true">2.6.</strong> Conditional Rendering</a></li><li class="chapter-item expanded "><a href="../learn/rendering-lists.html"><strong aria-hidden="true">2.7.</strong> Rendering Lists</a></li><li class="chapter-item expanded "><a href="../learn/keeping-components-pure.html"><strong aria-hidden="true">2.8.</strong> Keeping Components Pure</a></li></ol></li><li class="chapter-item expanded "><a href="../learn/adding-interactivity.html"><strong aria-hidden="true">3.</strong> Adding Interactivity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../learn/responding-to-events.html"><strong aria-hidden="true">3.1.</strong> Responding to Events</a></li><li class="chapter-item expanded "><a href="../learn/state-a-components-memory.html"><strong aria-hidden="true">3.2.</strong> State: A Component's Memory</a></li><li class="chapter-item expanded "><a href="../learn/render-and-commit.html"><strong aria-hidden="true">3.3.</strong> Render and Commit</a></li><li class="chapter-item expanded "><a href="../learn/state-as-a-snapshot.html"><strong aria-hidden="true">3.4.</strong> State as a Snapshot</a></li><li class="chapter-item expanded "><a href="../learn/queueing-a-series-of-state-updates.html"><strong aria-hidden="true">3.5.</strong> Queueing a Series of State Updates</a></li><li class="chapter-item expanded "><a href="../learn/updating-objects-in-state.html" class="active"><strong aria-hidden="true">3.6.</strong> Updating Objects in State</a></li><li class="chapter-item expanded "><a href="../learn/updating-arrays-in-state.html"><strong aria-hidden="true">3.7.</strong> Updating Arrays in State</a></li></ol></li><li class="chapter-item expanded "><a href="../learn/managing-state.html"><strong aria-hidden="true">4.</strong> Managing State</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../learn/reacting-to-input-with-state.html"><strong aria-hidden="true">4.1.</strong> Reacting to Input with State</a></li><li class="chapter-item expanded "><a href="../learn/choosing-the-state-structure.html"><strong aria-hidden="true">4.2.</strong> Choosing the State Structure</a></li><li class="chapter-item expanded "><a href="../learn/sharing-state-between-components.html"><strong aria-hidden="true">4.3.</strong> Sharing State Between Components</a></li><li class="chapter-item expanded "><a href="../learn/preserving-and-resetting-state.html"><strong aria-hidden="true">4.4.</strong> Preserving and Resetting State</a></li><li class="chapter-item expanded "><a href="../learn/extracting-state-logic-into-a-reducer.html"><strong aria-hidden="true">4.5.</strong> Extracting State Logic into a Reducer</a></li><li class="chapter-item expanded "><a href="../learn/passing-data-deeply-with-context.html"><strong aria-hidden="true">4.6.</strong> Passing Data Deeply with Context</a></li><li class="chapter-item expanded "><a href="../learn/scaling-up-with-reducer-and-context.html"><strong aria-hidden="true">4.7.</strong> Scaling Up with Reducer and Context</a></li></ol></li><li class="chapter-item expanded "><a href="../learn/escape-hatches.html"><strong aria-hidden="true">5.</strong> Escape Hatches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../learn/referencing-values-with-refs.html"><strong aria-hidden="true">5.1.</strong> Referencing Values with Refs</a></li><li class="chapter-item expanded "><a href="../learn/manipulating-the-dom-with-refs.html"><strong aria-hidden="true">5.2.</strong> Manipulating the DOM with Refs</a></li><li class="chapter-item expanded "><a href="../learn/synchronizing-with-effects.html"><strong aria-hidden="true">5.3.</strong> Synchronizing with Effects</a></li><li class="chapter-item expanded "><a href="../learn/you-might-not-need-an-effect.html"><strong aria-hidden="true">5.4.</strong> You Might Not Need an Effect</a></li><li class="chapter-item expanded "><a href="../learn/lifecycle-of-reactive-effects.html"><strong aria-hidden="true">5.5.</strong> Lifecycle of Reactive Effects</a></li><li class="chapter-item expanded "><a href="../learn/separating-events-from-effects.html"><strong aria-hidden="true">5.6.</strong> Separating Events from Effects</a></li><li class="chapter-item expanded "><a href="../learn/removing-effect-dependencies.html"><strong aria-hidden="true">5.7.</strong> Removing Effect Dependencies</a></li><li class="chapter-item expanded "><a href="../learn/reusing-logic-with-custom-hooks.html"><strong aria-hidden="true">5.8.</strong> Reusing Logic with Custom Hooks</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference</li><li class="chapter-item expanded affix "><li class="part-title">'react' package</li><li class="chapter-item expanded "><a href="../reference/react/components.html"><strong aria-hidden="true">6.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/react/Fragment.html"><strong aria-hidden="true">6.1.</strong> &lt;Fragment&gt; (&lt;&gt;...&lt;/&gt;)</a></li><li class="chapter-item expanded "><a href="../reference/react/Profiler.html"><strong aria-hidden="true">6.2.</strong> &lt;Profiler&gt;</a></li><li class="chapter-item expanded "><a href="../reference/react/StrictMode.html"><strong aria-hidden="true">6.3.</strong> &lt;StrictMode&gt;</a></li><li class="chapter-item expanded "><a href="../reference/react/Suspense.html"><strong aria-hidden="true">6.4.</strong> &lt;Suspense&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/react/index.html"><strong aria-hidden="true">7.</strong> Hooks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/react/useCallback.html"><strong aria-hidden="true">7.1.</strong> useCallback</a></li><li class="chapter-item expanded "><a href="../reference/react/useContext.html"><strong aria-hidden="true">7.2.</strong> useContext</a></li><li class="chapter-item expanded "><a href="../reference/react/useDebugValue.html"><strong aria-hidden="true">7.3.</strong> useDebugValue</a></li><li class="chapter-item expanded "><a href="../reference/react/useDeferredValue.html"><strong aria-hidden="true">7.4.</strong> useDeferredValue</a></li><li class="chapter-item expanded "><a href="../reference/react/useEffect.html"><strong aria-hidden="true">7.5.</strong> useEffect</a></li><li class="chapter-item expanded "><a href="../reference/react/useId.html"><strong aria-hidden="true">7.6.</strong> useId</a></li><li class="chapter-item expanded "><a href="../reference/react/useImperativeHandle.html"><strong aria-hidden="true">7.7.</strong> useImperativeHandle</a></li><li class="chapter-item expanded "><a href="../reference/react/useInsertionEffect.html"><strong aria-hidden="true">7.8.</strong> useInsertionEffect</a></li><li class="chapter-item expanded "><a href="../reference/react/useLayoutEffect.html"><strong aria-hidden="true">7.9.</strong> useLayoutEffect</a></li><li class="chapter-item expanded "><a href="../reference/react/useMemo.html"><strong aria-hidden="true">7.10.</strong> useMemo</a></li><li class="chapter-item expanded "><a href="../reference/react/useReducer.html"><strong aria-hidden="true">7.11.</strong> useReducer</a></li><li class="chapter-item expanded "><a href="../reference/react/useRef.html"><strong aria-hidden="true">7.12.</strong> useRef</a></li><li class="chapter-item expanded "><a href="../reference/react/useState.html"><strong aria-hidden="true">7.13.</strong> useState</a></li><li class="chapter-item expanded "><a href="../reference/react/useSyncExternalStore.html"><strong aria-hidden="true">7.14.</strong> useSyncExternalStore</a></li><li class="chapter-item expanded "><a href="../reference/react/useTransition.html"><strong aria-hidden="true">7.15.</strong> useTransition</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/react/apis.html"><strong aria-hidden="true">8.</strong> APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/react/createContext.html"><strong aria-hidden="true">8.1.</strong> createContext</a></li><li class="chapter-item expanded "><a href="../reference/react/forwardRef.html"><strong aria-hidden="true">8.2.</strong> forwardRef</a></li><li class="chapter-item expanded "><a href="../reference/react/lazy.html"><strong aria-hidden="true">8.3.</strong> lazy</a></li><li class="chapter-item expanded "><a href="../reference/react/memo.html"><strong aria-hidden="true">8.4.</strong> memo</a></li><li class="chapter-item expanded "><a href="../reference/react/startTransition.html"><strong aria-hidden="true">8.5.</strong> startTransition</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">'react-dom' package</li><li class="chapter-item expanded "><a href="../reference/react-dom/components/index.html"><strong aria-hidden="true">9.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/react-dom/components/common.html"><strong aria-hidden="true">9.1.</strong> Common components (e.g. &lt;div&gt;)</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/components/input.html"><strong aria-hidden="true">9.2.</strong> &lt;input&gt;</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/components/option.html"><strong aria-hidden="true">9.3.</strong> &lt;option&gt;</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/components/progress.html"><strong aria-hidden="true">9.4.</strong> &lt;progress&gt;</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/components/select.html"><strong aria-hidden="true">9.5.</strong> &lt;select&gt;</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/components/textarea.html"><strong aria-hidden="true">9.6.</strong> &lt;textarea&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/react-dom/index.html"><strong aria-hidden="true">10.</strong> APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/react-dom/createPortal.html"><strong aria-hidden="true">10.1.</strong> createPortal</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/flushSync.html"><strong aria-hidden="true">10.2.</strong> flushSync</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/findDOMNode.html"><strong aria-hidden="true">10.3.</strong> findDOMNode</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/hydrate.html"><strong aria-hidden="true">10.4.</strong> hydrate</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/render.html"><strong aria-hidden="true">10.5.</strong> render</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/unmountComponentAtNode.html"><strong aria-hidden="true">10.6.</strong> unmountComponentAtNode</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/react-dom/client/index.html"><strong aria-hidden="true">11.</strong> Client APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/react-dom/client/createRoot.html"><strong aria-hidden="true">11.1.</strong> createRoot</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/client/hydrateRoot.html"><strong aria-hidden="true">11.2.</strong> hydrateRoot</a></li></ol></li><li class="chapter-item expanded "><a href="../reference/react-dom/server/index.html"><strong aria-hidden="true">12.</strong> Server APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/react-dom/server/renderToNodeStream.html"><strong aria-hidden="true">12.1.</strong> renderToNodeStream</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/server/renderToPipeableStream.html"><strong aria-hidden="true">12.2.</strong> renderToPipeableStream</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/server/renderToReadableStream.html"><strong aria-hidden="true">12.3.</strong> renderToReadableStream</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/server/renderToStaticMarkup.html"><strong aria-hidden="true">12.4.</strong> renderToStaticMarkup</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/server/renderToStaticNodeStream.html"><strong aria-hidden="true">12.5.</strong> renderToStaticNodeStream</a></li><li class="chapter-item expanded "><a href="../reference/react-dom/server/renderToString.html"><strong aria-hidden="true">12.6.</strong> renderToString</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Legacy APIs</li><li class="chapter-item expanded "><a href="../reference/react/legacy.html"><strong aria-hidden="true">13.</strong> Legacy React APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../reference/react/Children.html"><strong aria-hidden="true">13.1.</strong> Children</a></li><li class="chapter-item expanded "><a href="../reference/react/cloneElement.html"><strong aria-hidden="true">13.2.</strong> cloneElement</a></li><li class="chapter-item expanded "><a href="../reference/react/Component.html"><strong aria-hidden="true">13.3.</strong> Component</a></li><li class="chapter-item expanded "><a href="../reference/react/createElement.html"><strong aria-hidden="true">13.4.</strong> createElement</a></li><li class="chapter-item expanded "><a href="../reference/react/createFactory.html"><strong aria-hidden="true">13.5.</strong> createFactory</a></li><li class="chapter-item expanded "><a href="../reference/react/createRef.html"><strong aria-hidden="true">13.6.</strong> createRef</a></li><li class="chapter-item expanded "><a href="../reference/react/isValidElement.html"><strong aria-hidden="true">13.7.</strong> isValidElement</a></li><li class="chapter-item expanded "><a href="../reference/react/PureComponent.html"><strong aria-hidden="true">13.8.</strong> PureComponent</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">React 18 Docs</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<h2 id="title-updating-objects-in-state"><a class="header" href="#title-updating-objects-in-state">title: Updating Objects in State</a></h2>
<Intro>
<p>State can hold any kind of JavaScript value, including objects. But you shouldn't change objects that you hold in the React state directly. Instead, when you want to update an object, you need to create a new one (or make a copy of an existing one), and then set the state to use that copy.</p>
</Intro>
<YouWillLearn>
<ul>
<li>How to correctly update an object in React state</li>
<li>How to update a nested object without mutating it</li>
<li>What immutability is, and how not to break it</li>
<li>How to make object copying less repetitive with Immer</li>
</ul>
</YouWillLearn>
<h2 id="whats-a-mutation-whats-a-mutation"><a class="header" href="#whats-a-mutation-whats-a-mutation">What's a mutation? {/<em>whats-a-mutation</em>/}</a></h2>
<p>You can store any kind of JavaScript value in state.</p>
<pre><code class="language-js">const [x, setX] = useState(0);
</code></pre>
<p>So far you've been working with numbers, strings, and booleans. These kinds of JavaScript values are &quot;immutable&quot;, meaning unchangeable or &quot;read-only&quot;. You can trigger a re-render to <em>replace</em> a value:</p>
<pre><code class="language-js">setX(5);
</code></pre>
<p>The <code>x</code> state changed from <code>0</code> to <code>5</code>, but the <em>number <code>0</code> itself</em> did not change. It's not possible to make any changes to the built-in primitive values like numbers, strings, and booleans in JavaScript.</p>
<p>Now consider an object in state:</p>
<pre><code class="language-js">const [position, setPosition] = useState({ x: 0, y: 0 });
</code></pre>
<p>Technically, it is possible to change the contents of <em>the object itself</em>. <strong>This is called a mutation:</strong></p>
<pre><code class="language-js">position.x = 5;
</code></pre>
<p>However, although objects in React state are technically mutable, you should treat them <strong>as if</strong> they were immutable--like numbers, booleans, and strings. Instead of mutating them, you should always replace them.</p>
<h2 id="treat-state-as-read-only-treat-state-as-read-only"><a class="header" href="#treat-state-as-read-only-treat-state-as-read-only">Treat state as read-only {/<em>treat-state-as-read-only</em>/}</a></h2>
<p>In other words, you should <strong>treat any JavaScript object that you put into state as read-only.</strong></p>
<p>This example holds an object in state to represent the current pointer position. The red dot is supposed to move when you touch or move the cursor over the preview area. But the dot stays in the initial position:</p>
<Sandpack>
<pre><code class="language-js">import { useState } from 'react';
export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0
  });
  return (
    &lt;div
      onPointerMove={e =&gt; {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}&gt;
      &lt;div style={{
        position: 'absolute',
        backgroundColor: 'red',
        borderRadius: '50%',
        transform: `translate(${position.x}px, ${position.y}px)`,
        left: -10,
        top: -10,
        width: 20,
        height: 20,
      }} /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<pre><code class="language-css">body { margin: 0; padding: 0; height: 250px; }
</code></pre>
</Sandpack>
<p>The problem is with this bit of code.</p>
<pre><code class="language-js">onPointerMove={e =&gt; {
  position.x = e.clientX;
  position.y = e.clientY;
}}
</code></pre>
<p>This code modifies the object assigned to <code>position</code> from <a href="/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time">the previous render.</a> But without using the state setting function, React has no idea that object has changed. So React does not do anything in response. It's like trying to change the order after you've already eaten the meal. While mutating state can work in some cases, we don't recommend it. You should treat the state value you have access to in a render as read-only.</p>
<p>To actually <a href="/learn/state-as-a-snapshot#setting-state-triggers-renders">trigger a re-render</a> in this case, <strong>create a <em>new</em> object and pass it to the state setting function:</strong></p>
<pre><code class="language-js">onPointerMove={e =&gt; {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}
</code></pre>
<p>With <code>setPosition</code>, you're telling React:</p>
<ul>
<li>Replace <code>position</code> with this new object</li>
<li>And render this component again</li>
</ul>
<p>Notice how the red dot now follows your pointer when you touch or hover over the preview area:</p>
<Sandpack>
<pre><code class="language-js">import { useState } from 'react';
export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0
  });
  return (
    &lt;div
      onPointerMove={e =&gt; {
        setPosition({
          x: e.clientX,
          y: e.clientY
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}&gt;
      &lt;div style={{
        position: 'absolute',
        backgroundColor: 'red',
        borderRadius: '50%',
        transform: `translate(${position.x}px, ${position.y}px)`,
        left: -10,
        top: -10,
        width: 20,
        height: 20,
      }} /&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<pre><code class="language-css">body { margin: 0; padding: 0; height: 250px; }
</code></pre>
</Sandpack>
<DeepDive>
<h4 id="local-mutation-is-fine-local-mutation-is-fine"><a class="header" href="#local-mutation-is-fine-local-mutation-is-fine">Local mutation is fine {/<em>local-mutation-is-fine</em>/}</a></h4>
<p>Code like this is a problem because it modifies an <em>existing</em> object in state:</p>
<pre><code class="language-js">position.x = e.clientX;
position.y = e.clientY;
</code></pre>
<p>But code like this is <strong>absolutely fine</strong> because you're mutating a fresh object you have <em>just created</em>:</p>
<pre><code class="language-js">const nextPosition = {};
nextPosition.x = e.clientX;
nextPosition.y = e.clientY;
setPosition(nextPosition);
</code></pre>
<p>In fact, it is completely equivalent to writing this:</p>
<pre><code class="language-js">setPosition({
  x: e.clientX,
  y: e.clientY
});
</code></pre>
<p>Mutation is only a problem when you change <em>existing</em> objects that are already in state. Mutating an object you've just created is okay because <em>no other code references it yet.</em> Changing it isn't going to accidentally impact something that depends on it. This is called a &quot;local mutation&quot;. You can even do local mutation <a href="/learn/keeping-components-pure#local-mutation-your-components-little-secret">while rendering.</a> Very convenient and completely okay!</p>
</DeepDive>  
<h2 id="copying-objects-with-the-spread-syntax-copying-objects-with-the-spread-syntax"><a class="header" href="#copying-objects-with-the-spread-syntax-copying-objects-with-the-spread-syntax">Copying objects with the spread syntax {/<em>copying-objects-with-the-spread-syntax</em>/}</a></h2>
<p>In the previous example, the <code>position</code> object is always created fresh from the current cursor position. But often, you will want to include <em>existing</em> data as a part of the new object you're creating. For example, you may want to update <em>only one</em> field in a form, but keep the previous values for all other fields.</p>
<p>These input fields don't work because the <code>onChange</code> handlers mutate the state:</p>
<Sandpack>
<pre><code class="language-js">import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleFirstNameChange(e) {
    person.firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    person.lastName = e.target.value;
  }

  function handleEmailChange(e) {
    person.email = e.target.value;
  }

  return (
    &lt;&gt;
      &lt;label&gt;
        First name:
        &lt;input
          value={person.firstName}
          onChange={handleFirstNameChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Last name:
        &lt;input
          value={person.lastName}
          onChange={handleLastNameChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Email:
        &lt;input
          value={person.email}
          onChange={handleEmailChange}
        /&gt;
      &lt;/label&gt;
      &lt;p&gt;
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      &lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-css">label { display: block; }
input { margin-left: 5px; margin-bottom: 5px; }
</code></pre>
</Sandpack>
<p>For example, this line mutates the state from a past render:</p>
<pre><code class="language-js">person.firstName = e.target.value;
</code></pre>
<p>The reliable way to get the behavior you're looking for is to create a new object and pass it to <code>setPerson</code>. But here, you want to also <strong>copy the existing data into it</strong> because only one of the fields has changed:</p>
<pre><code class="language-js">setPerson({
  firstName: e.target.value, // New first name from the input
  lastName: person.lastName,
  email: person.email
});
</code></pre>
<p>You can use the <code>...</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals">object spread</a> syntax so that you don't need to copy every property separately.</p>
<pre><code class="language-js">setPerson({
  ...person, // Copy the old fields
  firstName: e.target.value // But override this one
});
</code></pre>
<p>Now the form works! </p>
<p>Notice how you didn't declare a separate state variable for each input field. For large forms, keeping all data grouped in an object is very convenient--as long as you update it correctly!</p>
<Sandpack>
<pre><code class="language-js">import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleFirstNameChange(e) {
    setPerson({
      ...person,
      firstName: e.target.value
    });
  }

  function handleLastNameChange(e) {
    setPerson({
      ...person,
      lastName: e.target.value
    });
  }

  function handleEmailChange(e) {
    setPerson({
      ...person,
      email: e.target.value
    });
  }

  return (
    &lt;&gt;
      &lt;label&gt;
        First name:
        &lt;input
          value={person.firstName}
          onChange={handleFirstNameChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Last name:
        &lt;input
          value={person.lastName}
          onChange={handleLastNameChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Email:
        &lt;input
          value={person.email}
          onChange={handleEmailChange}
        /&gt;
      &lt;/label&gt;
      &lt;p&gt;
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      &lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-css">label { display: block; }
input { margin-left: 5px; margin-bottom: 5px; }
</code></pre>
</Sandpack>
<p>Note that the <code>...</code> spread syntax is &quot;shallow&quot;--it only copies things one level deep. This makes it fast, but it also means that if you want to update a nested property, you'll have to use it more than once. </p>
<DeepDive>
<h4 id="using-a-single-event-handler-for-multiple-fields-using-a-single-event-handler-for-multiple-fields"><a class="header" href="#using-a-single-event-handler-for-multiple-fields-using-a-single-event-handler-for-multiple-fields">Using a single event handler for multiple fields {/<em>using-a-single-event-handler-for-multiple-fields</em>/}</a></h4>
<p>You can also use the <code>[</code> and <code>]</code> braces inside your object definition to specify a property with dynamic name. Here is the same example, but with a single event handler instead of three different ones:</p>
<Sandpack>
<pre><code class="language-js">import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleChange(e) {
    setPerson({
      ...person,
      [e.target.name]: e.target.value
    });
  }

  return (
    &lt;&gt;
      &lt;label&gt;
        First name:
        &lt;input
          name=&quot;firstName&quot;
          value={person.firstName}
          onChange={handleChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Last name:
        &lt;input
          name=&quot;lastName&quot;
          value={person.lastName}
          onChange={handleChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Email:
        &lt;input
          name=&quot;email&quot;
          value={person.email}
          onChange={handleChange}
        /&gt;
      &lt;/label&gt;
      &lt;p&gt;
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      &lt;/p&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-css">label { display: block; }
input { margin-left: 5px; margin-bottom: 5px; }
</code></pre>
</Sandpack>
<p>Here, <code>e.target.name</code> refers to the <code>name</code> property given to the <code>&lt;input&gt;</code> DOM element.</p>
</DeepDive>
<h2 id="updating-a-nested-object-updating-a-nested-object"><a class="header" href="#updating-a-nested-object-updating-a-nested-object">Updating a nested object {/<em>updating-a-nested-object</em>/}</a></h2>
<p>Consider a nested object structure like this:</p>
<pre><code class="language-js">const [person, setPerson] = useState({
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  }
});
</code></pre>
<p>If you wanted to update <code>person.artwork.city</code>, it's clear how to do it with mutation:</p>
<pre><code class="language-js">person.artwork.city = 'New Delhi';
</code></pre>
<p>But in React, you treat state as immutable! In order to change <code>city</code>, you would first need to produce the new <code>artwork</code> object (pre-populated with data from the previous one), and then produce the new <code>person</code> object which points at the new <code>artwork</code>:</p>
<pre><code class="language-js">const nextArtwork = { ...person.artwork, city: 'New Delhi' };
const nextPerson = { ...person, artwork: nextArtwork };
setPerson(nextPerson);
</code></pre>
<p>Or, written as a single function call:</p>
<pre><code class="language-js">setPerson({
  ...person, // Copy other fields
  artwork: { // but replace the artwork
    ...person.artwork, // with the same one
    city: 'New Delhi' // but in New Delhi!
  }
});
</code></pre>
<p>This gets a bit wordy, but it works fine for many cases:</p>
<Sandpack>
<pre><code class="language-js">import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    }
  });

  function handleNameChange(e) {
    setPerson({
      ...person,
      name: e.target.value
    });
  }

  function handleTitleChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        title: e.target.value
      }
    });
  }

  function handleCityChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        city: e.target.value
      }
    });
  }

  function handleImageChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        image: e.target.value
      }
    });
  }

  return (
    &lt;&gt;
      &lt;label&gt;
        Name:
        &lt;input
          value={person.name}
          onChange={handleNameChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Title:
        &lt;input
          value={person.artwork.title}
          onChange={handleTitleChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        City:
        &lt;input
          value={person.artwork.city}
          onChange={handleCityChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Image:
        &lt;input
          value={person.artwork.image}
          onChange={handleImageChange}
        /&gt;
      &lt;/label&gt;
      &lt;p&gt;
        &lt;i&gt;{person.artwork.title}&lt;/i&gt;
        {' by '}
        {person.name}
        &lt;br /&gt;
        (located in {person.artwork.city})
      &lt;/p&gt;
      &lt;img 
        src={person.artwork.image} 
        alt={person.artwork.title}
      /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-css">label { display: block; }
input { margin-left: 5px; margin-bottom: 5px; }
img { width: 200px; height: 200px; }
</code></pre>
</Sandpack>
<DeepDive>
<h4 id="objects-are-not-really-nested-objects-are-not-really-nested"><a class="header" href="#objects-are-not-really-nested-objects-are-not-really-nested">Objects are not really nested {/<em>objects-are-not-really-nested</em>/}</a></h4>
<p>An object like this appears &quot;nested&quot; in code:</p>
<pre><code class="language-js">let obj = {
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  }
};
</code></pre>
<p>However, &quot;nesting&quot; is an inaccurate way to think about how objects behave. When the code executes, there is no such thing as a &quot;nested&quot; object. You are really looking at two different objects:</p>
<pre><code class="language-js">let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1
};
</code></pre>
<p>The <code>obj1</code> object is not &quot;inside&quot; <code>obj2</code>. For example, <code>obj3</code> could &quot;point&quot; at <code>obj1</code> too:</p>
<pre><code class="language-js">let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1
};

let obj3 = {
  name: 'Copycat',
  artwork: obj1
};
</code></pre>
<p>If you were to mutate <code>obj3.artwork.city</code>, it would affect both <code>obj2.artwork.city</code> and <code>obj1.city</code>. This is because <code>obj3.artwork</code>, <code>obj2.artwork</code>, and <code>obj1</code> are the same object. This is difficult to see when you think of objects as &quot;nested&quot;. Instead, they are separate objects &quot;pointing&quot; at each other with properties.</p>
</DeepDive>  
<h3 id="write-concise-update-logic-with-immer-write-concise-update-logic-with-immer"><a class="header" href="#write-concise-update-logic-with-immer-write-concise-update-logic-with-immer">Write concise update logic with Immer {/<em>write-concise-update-logic-with-immer</em>/}</a></h3>
<p>If your state is deeply nested, you might want to consider <a href="/learn/choosing-the-state-structure#avoid-deeply-nested-state">flattening it.</a> But, if you don't want to change your state structure, you might prefer a shortcut to nested spreads. <a href="https://github.com/immerjs/use-immer">Immer</a> is a popular library that lets you write using the convenient but mutating syntax and takes care of producing the copies for you. With Immer, the code you write looks like you are &quot;breaking the rules&quot; and mutating an object:</p>
<pre><code class="language-js">updatePerson(draft =&gt; {
  draft.artwork.city = 'Lagos';
});
</code></pre>
<p>But unlike a regular mutation, it doesn't overwrite the past state!</p>
<DeepDive>
<h4 id="how-does-immer-work-how-does-immer-work"><a class="header" href="#how-does-immer-work-how-does-immer-work">How does Immer work? {/<em>how-does-immer-work</em>/}</a></h4>
<p>The <code>draft</code> provided by Immer is a special type of object, called a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a>, that &quot;records&quot; what you do with it. This is why you can mutate it freely as much as you like! Under the hood, Immer figures out which parts of the <code>draft</code> have been changed, and produces a completely new object that contains your edits.</p>
</DeepDive>
<p>To try Immer:</p>
<ol>
<li>Add <code>use-immer</code> to your <code>package.json</code> as a dependency</li>
<li>Run <code>npm install</code></li>
<li>Then replace <code>import { useState } from 'react'</code> with <code>import { useImmer } from 'use-immer'</code></li>
</ol>
<p>Here is the above example converted to Immer:</p>
<Sandpack>
<pre><code class="language-js">import { useImmer } from 'use-immer';

export default function Form() {
  const [person, updatePerson] = useImmer({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    }
  });

  function handleNameChange(e) {
    updatePerson(draft =&gt; {
      draft.name = e.target.value;
    });
  }

  function handleTitleChange(e) {
    updatePerson(draft =&gt; {
      draft.artwork.title = e.target.value;
    });
  }

  function handleCityChange(e) {
    updatePerson(draft =&gt; {
      draft.artwork.city = e.target.value;
    });
  }

  function handleImageChange(e) {
    updatePerson(draft =&gt; {
      draft.artwork.image = e.target.value;
    });
  }

  return (
    &lt;&gt;
      &lt;label&gt;
        Name:
        &lt;input
          value={person.name}
          onChange={handleNameChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Title:
        &lt;input
          value={person.artwork.title}
          onChange={handleTitleChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        City:
        &lt;input
          value={person.artwork.city}
          onChange={handleCityChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Image:
        &lt;input
          value={person.artwork.image}
          onChange={handleImageChange}
        /&gt;
      &lt;/label&gt;
      &lt;p&gt;
        &lt;i&gt;{person.artwork.title}&lt;/i&gt;
        {' by '}
        {person.name}
        &lt;br /&gt;
        (located in {person.artwork.city})
      &lt;/p&gt;
      &lt;img 
        src={person.artwork.image} 
        alt={person.artwork.title}
      /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-json package.json">{
  &quot;dependencies&quot;: {
    &quot;immer&quot;: &quot;1.7.3&quot;,
    &quot;react&quot;: &quot;latest&quot;,
    &quot;react-dom&quot;: &quot;latest&quot;,
    &quot;react-scripts&quot;: &quot;latest&quot;,
    &quot;use-immer&quot;: &quot;0.5.1&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;
  }
}
</code></pre>
<pre><code class="language-css">label { display: block; }
input { margin-left: 5px; margin-bottom: 5px; }
img { width: 200px; height: 200px; }
</code></pre>
</Sandpack>
<p>Notice how much more concise the event handlers have become. You can mix and match <code>useState</code> and <code>useImmer</code> in a single component as much as you like. Immer is a great way to keep the update handlers concise, especially if there's nesting in your state, and copying objects leads to repetitive code.</p>
<DeepDive>
<h4 id="why-is-mutating-state-not-recommended-in-react-why-is-mutating-state-not-recommended-in-react"><a class="header" href="#why-is-mutating-state-not-recommended-in-react-why-is-mutating-state-not-recommended-in-react">Why is mutating state not recommended in React? {/<em>why-is-mutating-state-not-recommended-in-react</em>/}</a></h4>
<p>There are a few reasons:</p>
<ul>
<li><strong>Debugging:</strong> If you use <code>console.log</code> and don't mutate state, your past logs won't get clobbered by the more recent state changes. So you can clearly see how state has changed between renders.</li>
<li><strong>Optimizations:</strong> Common React <a href="/reference/react/memo">optimization strategies</a> rely on skipping work if previous props or state are the same as the next ones. If you never mutate state, it is very fast to check whether there were any changes. If <code>prevObj === obj</code>, you can be sure that nothing could have changed inside of it.</li>
<li><strong>New Features:</strong> The new React features we're building rely on state being <a href="/learn/state-as-a-snapshot">treated like a snapshot.</a> If you're mutating past versions of state, that may prevent you from using the new features.</li>
<li><strong>Requirement Changes:</strong> Some application features, like implementing Undo/Redo, showing a history of changes, or letting the user reset a form to earlier values, are easier to do when nothing is mutated. This is because you can keep past copies of state in memory, and reuse them when appropriate. If you start with a mutative approach, features like this can be difficult to add later on.</li>
<li><strong>Simpler Implementation:</strong> Because React does not rely on mutation, it does not need to do anything special with your objects. It does not need to hijack their properties, always wrap them into Proxies, or do other work at initialization as many &quot;reactive&quot; solutions do. This is also why React lets you put any object into state--no matter how large--without additional performance or correctness pitfalls.</li>
</ul>
<p>In practice, you can often &quot;get away&quot; with mutating state in React, but we strongly advise you not to do that so that you can use new React features developed with this approach in mind. Future contributors and perhaps even your future self will thank you!</p>
</DeepDive>
<Recap>
<ul>
<li>Treat all state in React as immutable.</li>
<li>When you store objects in state, mutating them will not trigger renders and will change the state in previous render &quot;snapshots&quot;.</li>
<li>Instead of mutating an object, create a <em>new</em> version of it, and trigger a re-render by setting state to it.</li>
<li>You can use the <code>{...obj, something: 'newValue'}</code> object spread syntax to create copies of objects.</li>
<li>Spread syntax is shallow: it only copies one level deep.</li>
<li>To update a nested object, you need to create copies all the way up from the place you're updating.</li>
<li>To reduce repetitive copying code, use Immer.</li>
</ul>
</Recap>
<Challenges>
<h4 id="fix-incorrect-state-updates-fix-incorrect-state-updates"><a class="header" href="#fix-incorrect-state-updates-fix-incorrect-state-updates">Fix incorrect state updates {/<em>fix-incorrect-state-updates</em>/}</a></h4>
<p>This form has a few bugs. Click the button that increases the score a few times. Notice that it does not increase. Then edit the first name, and notice that the score has suddenly &quot;caught up&quot; with your changes. Finally, edit the last name, and notice that the score has disappeared completely.</p>
<p>Your task is to fix all of these bugs. As you fix them, explain why each of them happens.</p>
<Sandpack>
<pre><code class="language-js">import { useState } from 'react';

export default function Scoreboard() {
  const [player, setPlayer] = useState({
    firstName: 'Ranjani',
    lastName: 'Shettar',
    score: 10,
  });

  function handlePlusClick() {
    player.score++;
  }

  function handleFirstNameChange(e) {
    setPlayer({
      ...player,
      firstName: e.target.value,
    });
  }

  function handleLastNameChange(e) {
    setPlayer({
      lastName: e.target.value
    });
  }

  return (
    &lt;&gt;
      &lt;label&gt;
        Score: &lt;b&gt;{player.score}&lt;/b&gt;
        {' '}
        &lt;button onClick={handlePlusClick}&gt;
          +1
        &lt;/button&gt;
      &lt;/label&gt;
      &lt;label&gt;
        First name:
        &lt;input
          value={player.firstName}
          onChange={handleFirstNameChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Last name:
        &lt;input
          value={player.lastName}
          onChange={handleLastNameChange}
        /&gt;
      &lt;/label&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-css">label { display: block; margin-bottom: 10px; }
input { margin-left: 5px; margin-bottom: 5px; }
</code></pre>
</Sandpack>
<Solution>
<p>Here is a version with both bugs fixed:</p>
<Sandpack>
<pre><code class="language-js">import { useState } from 'react';

export default function Scoreboard() {
  const [player, setPlayer] = useState({
    firstName: 'Ranjani',
    lastName: 'Shettar',
    score: 10,
  });

  function handlePlusClick() {
    setPlayer({
      ...player,
      score: player.score + 1,
    });
  }

  function handleFirstNameChange(e) {
    setPlayer({
      ...player,
      firstName: e.target.value,
    });
  }

  function handleLastNameChange(e) {
    setPlayer({
      ...player,
      lastName: e.target.value
    });
  }

  return (
    &lt;&gt;
      &lt;label&gt;
        Score: &lt;b&gt;{player.score}&lt;/b&gt;
        {' '}
        &lt;button onClick={handlePlusClick}&gt;
          +1
        &lt;/button&gt;
      &lt;/label&gt;
      &lt;label&gt;
        First name:
        &lt;input
          value={player.firstName}
          onChange={handleFirstNameChange}
        /&gt;
      &lt;/label&gt;
      &lt;label&gt;
        Last name:
        &lt;input
          value={player.lastName}
          onChange={handleLastNameChange}
        /&gt;
      &lt;/label&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-css">label { display: block; }
input { margin-left: 5px; margin-bottom: 5px; }
</code></pre>
</Sandpack>
<p>The problem with <code>handlePlusClick</code> was that it mutated the <code>player</code> object. As a result, React did not know that there's a reason to re-render, and did not update the score on the screen. This is why, when you edited the first name, the state got updated, triggering a re-render which <em>also</em> updated the score on the screen.</p>
<p>The problem with <code>handleLastNameChange</code> was that it did not copy the existing <code>...player</code> fields into the new object. This is why the score got lost after you edited the last name.</p>
</Solution>
<h4 id="find-and-fix-the-mutation-find-and-fix-the-mutation"><a class="header" href="#find-and-fix-the-mutation-find-and-fix-the-mutation">Find and fix the mutation {/<em>find-and-fix-the-mutation</em>/}</a></h4>
<p>There is a draggable box on a static background. You can change the box's color using the select input.</p>
<p>But there is a bug. If you move the box first, and then change its color, the background (which isn't supposed to move!) will &quot;jump&quot; to the box position. But this should not happen: the <code>Background</code>'s <code>position</code> prop is set to <code>initialPosition</code>, which is <code>{ x: 0, y: 0 }</code>. Why is the background moving after the color change?</p>
<p>Find the bug and fix it.</p>
<Hint>
<p>If something unexpected changes, there is a mutation. Find the mutation in <code>App.js</code> and fix it.</p>
</Hint>
<Sandpack>
<pre><code class="language-js App.js">import { useState } from 'react';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition
  });

  function handleMove(dx, dy) {
    shape.position.x += dx;
    shape.position.y += dy;
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value
    });
  }

  return (
    &lt;&gt;
      &lt;select
        value={shape.color}
        onChange={handleColorChange}
      &gt;
        &lt;option value=&quot;orange&quot;&gt;orange&lt;/option&gt;
        &lt;option value=&quot;lightpink&quot;&gt;lightpink&lt;/option&gt;
        &lt;option value=&quot;aliceblue&quot;&gt;aliceblue&lt;/option&gt;
      &lt;/select&gt;
      &lt;Background
        position={initialPosition}
      /&gt;
      &lt;Box
        color={shape.color}
        position={shape.position}
        onMove={handleMove}
      &gt;
        Drag me!
      &lt;/Box&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-js Box.js">import { useState } from 'react';

export default function Box({
  children,
  color,
  position,
  onMove
}) {
  const [
    lastCoordinates,
    setLastCoordinates
  ] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    &lt;div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    &gt;{children}&lt;/div&gt;
  );
}
</code></pre>
<pre><code class="language-js Background.js">export default function Background({
  position
}) {
  return (
    &lt;div style={{
      position: 'absolute',
      transform: `translate(
        ${position.x}px,
        ${position.y}px
      )`,
      width: 250,
      height: 250,
      backgroundColor: 'rgba(200, 200, 0, 0.2)',
    }} /&gt;
  );
};
</code></pre>
<pre><code class="language-css">body { height: 280px; }
select { margin-bottom: 10px; }
</code></pre>
</Sandpack>
<Solution>
<p>The problem was in the mutation inside <code>handleMove</code>. It mutated <code>shape.position</code>, but that's the same object that <code>initialPosition</code> points at. This is why both the shape and the background move. (It's a mutation, so the change doesn't reflect on the screen until an unrelated update--the color change--triggers a re-render.)</p>
<p>The fix is to remove the mutation from <code>handleMove</code>, and use the spread syntax to copy the shape. Note that <code>+=</code> is a mutation, so you need to rewrite it to use a regular <code>+</code> operation.</p>
<Sandpack>
<pre><code class="language-js App.js">import { useState } from 'react';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition
  });

  function handleMove(dx, dy) {
    setShape({
      ...shape,
      position: {
        x: shape.position.x + dx,
        y: shape.position.y + dy,
      }
    });
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value
    });
  }

  return (
    &lt;&gt;
      &lt;select
        value={shape.color}
        onChange={handleColorChange}
      &gt;
        &lt;option value=&quot;orange&quot;&gt;orange&lt;/option&gt;
        &lt;option value=&quot;lightpink&quot;&gt;lightpink&lt;/option&gt;
        &lt;option value=&quot;aliceblue&quot;&gt;aliceblue&lt;/option&gt;
      &lt;/select&gt;
      &lt;Background
        position={initialPosition}
      /&gt;
      &lt;Box
        color={shape.color}
        position={shape.position}
        onMove={handleMove}
      &gt;
        Drag me!
      &lt;/Box&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-js Box.js">import { useState } from 'react';

export default function Box({
  children,
  color,
  position,
  onMove
}) {
  const [
    lastCoordinates,
    setLastCoordinates
  ] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    &lt;div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    &gt;{children}&lt;/div&gt;
  );
}
</code></pre>
<pre><code class="language-js Background.js">export default function Background({
  position
}) {
  return (
    &lt;div style={{
      position: 'absolute',
      transform: `translate(
        ${position.x}px,
        ${position.y}px
      )`,
      width: 250,
      height: 250,
      backgroundColor: 'rgba(200, 200, 0, 0.2)',
    }} /&gt;
  );
};
</code></pre>
<pre><code class="language-css">body { height: 280px; }
select { margin-bottom: 10px; }
</code></pre>
</Sandpack>
</Solution>
<h4 id="update-an-object-with-immer-update-an-object-with-immer"><a class="header" href="#update-an-object-with-immer-update-an-object-with-immer">Update an object with Immer {/<em>update-an-object-with-immer</em>/}</a></h4>
<p>This is the same buggy example as in the previous challenge. This time, fix the mutation by using Immer. For your convenience, <code>useImmer</code> is already imported, so you need to change the <code>shape</code> state variable to use it.</p>
<Sandpack>
<pre><code class="language-js App.js">import { useState } from 'react';
import { useImmer } from 'use-immer';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0
};

export default function Canvas() {
  const [shape, setShape] = useState({
    color: 'orange',
    position: initialPosition
  });

  function handleMove(dx, dy) {
    shape.position.x += dx;
    shape.position.y += dy;
  }

  function handleColorChange(e) {
    setShape({
      ...shape,
      color: e.target.value
    });
  }

  return (
    &lt;&gt;
      &lt;select
        value={shape.color}
        onChange={handleColorChange}
      &gt;
        &lt;option value=&quot;orange&quot;&gt;orange&lt;/option&gt;
        &lt;option value=&quot;lightpink&quot;&gt;lightpink&lt;/option&gt;
        &lt;option value=&quot;aliceblue&quot;&gt;aliceblue&lt;/option&gt;
      &lt;/select&gt;
      &lt;Background
        position={initialPosition}
      /&gt;
      &lt;Box
        color={shape.color}
        position={shape.position}
        onMove={handleMove}
      &gt;
        Drag me!
      &lt;/Box&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-js Box.js">import { useState } from 'react';

export default function Box({
  children,
  color,
  position,
  onMove
}) {
  const [
    lastCoordinates,
    setLastCoordinates
  ] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    &lt;div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    &gt;{children}&lt;/div&gt;
  );
}
</code></pre>
<pre><code class="language-js Background.js">export default function Background({
  position
}) {
  return (
    &lt;div style={{
      position: 'absolute',
      transform: `translate(
        ${position.x}px,
        ${position.y}px
      )`,
      width: 250,
      height: 250,
      backgroundColor: 'rgba(200, 200, 0, 0.2)',
    }} /&gt;
  );
};
</code></pre>
<pre><code class="language-css">body { height: 280px; }
select { margin-bottom: 10px; }
</code></pre>
<pre><code class="language-json package.json">{
  &quot;dependencies&quot;: {
    &quot;immer&quot;: &quot;1.7.3&quot;,
    &quot;react&quot;: &quot;latest&quot;,
    &quot;react-dom&quot;: &quot;latest&quot;,
    &quot;react-scripts&quot;: &quot;latest&quot;,
    &quot;use-immer&quot;: &quot;0.5.1&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;
  }
}
</code></pre>
</Sandpack>
<Solution>
<p>This is the solution rewritten with Immer. Notice how the event handlers are written in a mutating fashion, but the bug does not occur. This is because under the hood, Immer never mutates the existing objects.</p>
<Sandpack>
<pre><code class="language-js App.js">import { useImmer } from 'use-immer';
import Background from './Background.js';
import Box from './Box.js';

const initialPosition = {
  x: 0,
  y: 0
};

export default function Canvas() {
  const [shape, updateShape] = useImmer({
    color: 'orange',
    position: initialPosition
  });

  function handleMove(dx, dy) {
    updateShape(draft =&gt; {
      draft.position.x += dx;
      draft.position.y += dy;
    });
  }

  function handleColorChange(e) {
    updateShape(draft =&gt; {
      draft.color = e.target.value;
    });
  }

  return (
    &lt;&gt;
      &lt;select
        value={shape.color}
        onChange={handleColorChange}
      &gt;
        &lt;option value=&quot;orange&quot;&gt;orange&lt;/option&gt;
        &lt;option value=&quot;lightpink&quot;&gt;lightpink&lt;/option&gt;
        &lt;option value=&quot;aliceblue&quot;&gt;aliceblue&lt;/option&gt;
      &lt;/select&gt;
      &lt;Background
        position={initialPosition}
      /&gt;
      &lt;Box
        color={shape.color}
        position={shape.position}
        onMove={handleMove}
      &gt;
        Drag me!
      &lt;/Box&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-js Box.js">import { useState } from 'react';

export default function Box({
  children,
  color,
  position,
  onMove
}) {
  const [
    lastCoordinates,
    setLastCoordinates
  ] = useState(null);

  function handlePointerDown(e) {
    e.target.setPointerCapture(e.pointerId);
    setLastCoordinates({
      x: e.clientX,
      y: e.clientY,
    });
  }

  function handlePointerMove(e) {
    if (lastCoordinates) {
      setLastCoordinates({
        x: e.clientX,
        y: e.clientY,
      });
      const dx = e.clientX - lastCoordinates.x;
      const dy = e.clientY - lastCoordinates.y;
      onMove(dx, dy);
    }
  }

  function handlePointerUp(e) {
    setLastCoordinates(null);
  }

  return (
    &lt;div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        width: 100,
        height: 100,
        cursor: 'grab',
        backgroundColor: color,
        position: 'absolute',
        border: '1px solid black',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        transform: `translate(
          ${position.x}px,
          ${position.y}px
        )`,
      }}
    &gt;{children}&lt;/div&gt;
  );
}
</code></pre>
<pre><code class="language-js Background.js">export default function Background({
  position
}) {
  return (
    &lt;div style={{
      position: 'absolute',
      transform: `translate(
        ${position.x}px,
        ${position.y}px
      )`,
      width: 250,
      height: 250,
      backgroundColor: 'rgba(200, 200, 0, 0.2)',
    }} /&gt;
  );
};
</code></pre>
<pre><code class="language-css">body { height: 280px; }
select { margin-bottom: 10px; }
</code></pre>
<pre><code class="language-json package.json">{
  &quot;dependencies&quot;: {
    &quot;immer&quot;: &quot;1.7.3&quot;,
    &quot;react&quot;: &quot;latest&quot;,
    &quot;react-dom&quot;: &quot;latest&quot;,
    &quot;react-scripts&quot;: &quot;latest&quot;,
    &quot;use-immer&quot;: &quot;0.5.1&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;
  }
}
</code></pre>
</Sandpack>
</Solution>
</Challenges>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../learn/queueing-a-series-of-state-updates.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../learn/updating-arrays-in-state.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../learn/queueing-a-series-of-state-updates.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../learn/updating-arrays-in-state.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
