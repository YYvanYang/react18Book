<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>useDeferredValue - React 18 Docs</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Get Started</li><li class="chapter-item expanded "><a href="../../learn/index.html"><strong aria-hidden="true">1.</strong> Quick Start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../learn/tutorial-tic-tac-toe.html"><strong aria-hidden="true">1.1.</strong> Tutorial: Tic-Tac-Toe</a></li><li class="chapter-item expanded "><a href="../../learn/thinking-in-react.html"><strong aria-hidden="true">1.2.</strong> Thinking in React</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Learn React</li><li class="chapter-item expanded "><a href="../../learn/describing-the-ui.html"><strong aria-hidden="true">2.</strong> Describing the UI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../learn/your-first-component.html"><strong aria-hidden="true">2.1.</strong> Your First Component</a></li><li class="chapter-item expanded "><a href="../../learn/importing-and-exporting-components.html"><strong aria-hidden="true">2.2.</strong> Importing and Exporting Components</a></li><li class="chapter-item expanded "><a href="../../learn/writing-markup-with-jsx.html"><strong aria-hidden="true">2.3.</strong> WritiPng Markup with JSX</a></li><li class="chapter-item expanded "><a href="../../learn/javascript-in-jsx-with-curly-braces.html"><strong aria-hidden="true">2.4.</strong> JavaScript in JSX with Curly Braces</a></li><li class="chapter-item expanded "><a href="../../learn/passing-props-to-a-component.html"><strong aria-hidden="true">2.5.</strong> Passing Props to a Component</a></li><li class="chapter-item expanded "><a href="../../learn/conditional-rendering.html"><strong aria-hidden="true">2.6.</strong> Conditional Rendering</a></li><li class="chapter-item expanded "><a href="../../learn/rendering-lists.html"><strong aria-hidden="true">2.7.</strong> Rendering Lists</a></li><li class="chapter-item expanded "><a href="../../learn/keeping-components-pure.html"><strong aria-hidden="true">2.8.</strong> Keeping Components Pure</a></li></ol></li><li class="chapter-item expanded "><a href="../../learn/adding-interactivity.html"><strong aria-hidden="true">3.</strong> Adding Interactivity</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../learn/responding-to-events.html"><strong aria-hidden="true">3.1.</strong> Responding to Events</a></li><li class="chapter-item expanded "><a href="../../learn/state-a-components-memory.html"><strong aria-hidden="true">3.2.</strong> State: A Component's Memory</a></li><li class="chapter-item expanded "><a href="../../learn/render-and-commit.html"><strong aria-hidden="true">3.3.</strong> Render and Commit</a></li><li class="chapter-item expanded "><a href="../../learn/state-as-a-snapshot.html"><strong aria-hidden="true">3.4.</strong> State as a Snapshot</a></li><li class="chapter-item expanded "><a href="../../learn/queueing-a-series-of-state-updates.html"><strong aria-hidden="true">3.5.</strong> Queueing a Series of State Updates</a></li><li class="chapter-item expanded "><a href="../../learn/updating-objects-in-state.html"><strong aria-hidden="true">3.6.</strong> Updating Objects in State</a></li><li class="chapter-item expanded "><a href="../../learn/updating-arrays-in-state.html"><strong aria-hidden="true">3.7.</strong> Updating Arrays in State</a></li></ol></li><li class="chapter-item expanded "><a href="../../learn/managing-state.html"><strong aria-hidden="true">4.</strong> Managing State</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../learn/reacting-to-input-with-state.html"><strong aria-hidden="true">4.1.</strong> Reacting to Input with State</a></li><li class="chapter-item expanded "><a href="../../learn/choosing-the-state-structure.html"><strong aria-hidden="true">4.2.</strong> Choosing the State Structure</a></li><li class="chapter-item expanded "><a href="../../learn/sharing-state-between-components.html"><strong aria-hidden="true">4.3.</strong> Sharing State Between Components</a></li><li class="chapter-item expanded "><a href="../../learn/preserving-and-resetting-state.html"><strong aria-hidden="true">4.4.</strong> Preserving and Resetting State</a></li><li class="chapter-item expanded "><a href="../../learn/extracting-state-logic-into-a-reducer.html"><strong aria-hidden="true">4.5.</strong> Extracting State Logic into a Reducer</a></li><li class="chapter-item expanded "><a href="../../learn/passing-data-deeply-with-context.html"><strong aria-hidden="true">4.6.</strong> Passing Data Deeply with Context</a></li><li class="chapter-item expanded "><a href="../../learn/scaling-up-with-reducer-and-context.html"><strong aria-hidden="true">4.7.</strong> Scaling Up with Reducer and Context</a></li></ol></li><li class="chapter-item expanded "><a href="../../learn/escape-hatches.html"><strong aria-hidden="true">5.</strong> Escape Hatches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../learn/referencing-values-with-refs.html"><strong aria-hidden="true">5.1.</strong> Referencing Values with Refs</a></li><li class="chapter-item expanded "><a href="../../learn/manipulating-the-dom-with-refs.html"><strong aria-hidden="true">5.2.</strong> Manipulating the DOM with Refs</a></li><li class="chapter-item expanded "><a href="../../learn/synchronizing-with-effects.html"><strong aria-hidden="true">5.3.</strong> Synchronizing with Effects</a></li><li class="chapter-item expanded "><a href="../../learn/you-might-not-need-an-effect.html"><strong aria-hidden="true">5.4.</strong> You Might Not Need an Effect</a></li><li class="chapter-item expanded "><a href="../../learn/lifecycle-of-reactive-effects.html"><strong aria-hidden="true">5.5.</strong> Lifecycle of Reactive Effects</a></li><li class="chapter-item expanded "><a href="../../learn/separating-events-from-effects.html"><strong aria-hidden="true">5.6.</strong> Separating Events from Effects</a></li><li class="chapter-item expanded "><a href="../../learn/removing-effect-dependencies.html"><strong aria-hidden="true">5.7.</strong> Removing Effect Dependencies</a></li><li class="chapter-item expanded "><a href="../../learn/reusing-logic-with-custom-hooks.html"><strong aria-hidden="true">5.8.</strong> Reusing Logic with Custom Hooks</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Reference</li><li class="chapter-item expanded affix "><li class="part-title">'react' package</li><li class="chapter-item expanded "><a href="../../reference/react/components.html"><strong aria-hidden="true">6.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../reference/react/Fragment.html"><strong aria-hidden="true">6.1.</strong> &lt;Fragment&gt; (&lt;&gt;...&lt;/&gt;)</a></li><li class="chapter-item expanded "><a href="../../reference/react/Profiler.html"><strong aria-hidden="true">6.2.</strong> &lt;Profiler&gt;</a></li><li class="chapter-item expanded "><a href="../../reference/react/StrictMode.html"><strong aria-hidden="true">6.3.</strong> &lt;StrictMode&gt;</a></li><li class="chapter-item expanded "><a href="../../reference/react/Suspense.html"><strong aria-hidden="true">6.4.</strong> &lt;Suspense&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="../../reference/react/index.html"><strong aria-hidden="true">7.</strong> Hooks</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../reference/react/useCallback.html"><strong aria-hidden="true">7.1.</strong> useCallback</a></li><li class="chapter-item expanded "><a href="../../reference/react/useContext.html"><strong aria-hidden="true">7.2.</strong> useContext</a></li><li class="chapter-item expanded "><a href="../../reference/react/useDebugValue.html"><strong aria-hidden="true">7.3.</strong> useDebugValue</a></li><li class="chapter-item expanded "><a href="../../reference/react/useDeferredValue.html" class="active"><strong aria-hidden="true">7.4.</strong> useDeferredValue</a></li><li class="chapter-item expanded "><a href="../../reference/react/useEffect.html"><strong aria-hidden="true">7.5.</strong> useEffect</a></li><li class="chapter-item expanded "><a href="../../reference/react/useId.html"><strong aria-hidden="true">7.6.</strong> useId</a></li><li class="chapter-item expanded "><a href="../../reference/react/useImperativeHandle.html"><strong aria-hidden="true">7.7.</strong> useImperativeHandle</a></li><li class="chapter-item expanded "><a href="../../reference/react/useInsertionEffect.html"><strong aria-hidden="true">7.8.</strong> useInsertionEffect</a></li><li class="chapter-item expanded "><a href="../../reference/react/useLayoutEffect.html"><strong aria-hidden="true">7.9.</strong> useLayoutEffect</a></li><li class="chapter-item expanded "><a href="../../reference/react/useMemo.html"><strong aria-hidden="true">7.10.</strong> useMemo</a></li><li class="chapter-item expanded "><a href="../../reference/react/useReducer.html"><strong aria-hidden="true">7.11.</strong> useReducer</a></li><li class="chapter-item expanded "><a href="../../reference/react/useRef.html"><strong aria-hidden="true">7.12.</strong> useRef</a></li><li class="chapter-item expanded "><a href="../../reference/react/useState.html"><strong aria-hidden="true">7.13.</strong> useState</a></li><li class="chapter-item expanded "><a href="../../reference/react/useSyncExternalStore.html"><strong aria-hidden="true">7.14.</strong> useSyncExternalStore</a></li><li class="chapter-item expanded "><a href="../../reference/react/useTransition.html"><strong aria-hidden="true">7.15.</strong> useTransition</a></li></ol></li><li class="chapter-item expanded "><a href="../../reference/react/apis.html"><strong aria-hidden="true">8.</strong> APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../reference/react/createContext.html"><strong aria-hidden="true">8.1.</strong> createContext</a></li><li class="chapter-item expanded "><a href="../../reference/react/forwardRef.html"><strong aria-hidden="true">8.2.</strong> forwardRef</a></li><li class="chapter-item expanded "><a href="../../reference/react/lazy.html"><strong aria-hidden="true">8.3.</strong> lazy</a></li><li class="chapter-item expanded "><a href="../../reference/react/memo.html"><strong aria-hidden="true">8.4.</strong> memo</a></li><li class="chapter-item expanded "><a href="../../reference/react/startTransition.html"><strong aria-hidden="true">8.5.</strong> startTransition</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">'react-dom' package</li><li class="chapter-item expanded "><a href="../../reference/react-dom/components/index.html"><strong aria-hidden="true">9.</strong> Components</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../reference/react-dom/components/common.html"><strong aria-hidden="true">9.1.</strong> Common components (e.g. &lt;div&gt;)</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/components/input.html"><strong aria-hidden="true">9.2.</strong> &lt;input&gt;</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/components/option.html"><strong aria-hidden="true">9.3.</strong> &lt;option&gt;</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/components/progress.html"><strong aria-hidden="true">9.4.</strong> &lt;progress&gt;</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/components/select.html"><strong aria-hidden="true">9.5.</strong> &lt;select&gt;</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/components/textarea.html"><strong aria-hidden="true">9.6.</strong> &lt;textarea&gt;</a></li></ol></li><li class="chapter-item expanded "><a href="../../reference/react-dom/index.html"><strong aria-hidden="true">10.</strong> APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../reference/react-dom/createPortal.html"><strong aria-hidden="true">10.1.</strong> createPortal</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/flushSync.html"><strong aria-hidden="true">10.2.</strong> flushSync</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/findDOMNode.html"><strong aria-hidden="true">10.3.</strong> findDOMNode</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/hydrate.html"><strong aria-hidden="true">10.4.</strong> hydrate</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/render.html"><strong aria-hidden="true">10.5.</strong> render</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/unmountComponentAtNode.html"><strong aria-hidden="true">10.6.</strong> unmountComponentAtNode</a></li></ol></li><li class="chapter-item expanded "><a href="../../reference/react-dom/client/index.html"><strong aria-hidden="true">11.</strong> Client APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../reference/react-dom/client/createRoot.html"><strong aria-hidden="true">11.1.</strong> createRoot</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/client/hydrateRoot.html"><strong aria-hidden="true">11.2.</strong> hydrateRoot</a></li></ol></li><li class="chapter-item expanded "><a href="../../reference/react-dom/server/index.html"><strong aria-hidden="true">12.</strong> Server APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../reference/react-dom/server/renderToNodeStream.html"><strong aria-hidden="true">12.1.</strong> renderToNodeStream</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/server/renderToPipeableStream.html"><strong aria-hidden="true">12.2.</strong> renderToPipeableStream</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/server/renderToReadableStream.html"><strong aria-hidden="true">12.3.</strong> renderToReadableStream</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/server/renderToStaticMarkup.html"><strong aria-hidden="true">12.4.</strong> renderToStaticMarkup</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/server/renderToStaticNodeStream.html"><strong aria-hidden="true">12.5.</strong> renderToStaticNodeStream</a></li><li class="chapter-item expanded "><a href="../../reference/react-dom/server/renderToString.html"><strong aria-hidden="true">12.6.</strong> renderToString</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Legacy APIs</li><li class="chapter-item expanded "><a href="../../reference/react/legacy.html"><strong aria-hidden="true">13.</strong> Legacy React APIs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../reference/react/Children.html"><strong aria-hidden="true">13.1.</strong> Children</a></li><li class="chapter-item expanded "><a href="../../reference/react/cloneElement.html"><strong aria-hidden="true">13.2.</strong> cloneElement</a></li><li class="chapter-item expanded "><a href="../../reference/react/Component.html"><strong aria-hidden="true">13.3.</strong> Component</a></li><li class="chapter-item expanded "><a href="../../reference/react/createElement.html"><strong aria-hidden="true">13.4.</strong> createElement</a></li><li class="chapter-item expanded "><a href="../../reference/react/createFactory.html"><strong aria-hidden="true">13.5.</strong> createFactory</a></li><li class="chapter-item expanded "><a href="../../reference/react/createRef.html"><strong aria-hidden="true">13.6.</strong> createRef</a></li><li class="chapter-item expanded "><a href="../../reference/react/isValidElement.html"><strong aria-hidden="true">13.7.</strong> isValidElement</a></li><li class="chapter-item expanded "><a href="../../reference/react/PureComponent.html"><strong aria-hidden="true">13.8.</strong> PureComponent</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">React 18 Docs</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <hr />
<h2 id="title-usedeferredvalue"><a class="header" href="#title-usedeferredvalue">title: useDeferredValue</a></h2>
<Intro>
<p><code>useDeferredValue</code> is a React Hook that lets you defer updating a part of the UI.</p>
<pre><code class="language-js">const deferredValue = useDeferredValue(value)
</code></pre>
</Intro>
<InlineToc />
<hr />
<h2 id="reference-reference"><a class="header" href="#reference-reference">Reference {/<em>reference</em>/}</a></h2>
<h3 id="usedeferredvaluevalue-usedeferredvalue"><a class="header" href="#usedeferredvaluevalue-usedeferredvalue"><code>useDeferredValue(value)</code> {/<em>usedeferredvalue</em>/}</a></h3>
<p>Call <code>useDeferredValue</code> at the top level of your component to get a deferred version of that value.</p>
<pre><code class="language-js">import { useState, useDeferredValue } from 'react';

function SearchPage() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  // ...
}
</code></pre>
<p><a href="#usage">See more examples below.</a></p>
<h4 id="parameters-parameters"><a class="header" href="#parameters-parameters">Parameters {/<em>parameters</em>/}</a></h4>
<ul>
<li><code>value</code>: The value you want to defer. It can have any type.</li>
</ul>
<h4 id="returns-returns"><a class="header" href="#returns-returns">Returns {/<em>returns</em>/}</a></h4>
<p>During the initial render, the returned deferred value will be the same as the value you provided. During updates, React will first attempt a re-render with the old value (so the returned value will match the old value), and then try another re-render in background with the new value (so the returned value will match the updated value). </p>
<h4 id="caveats-caveats"><a class="header" href="#caveats-caveats">Caveats {/<em>caveats</em>/}</a></h4>
<ul>
<li>
<p>The values you pass to <code>useDeferredValue</code> should either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it to <code>useDeferredValue</code>, it will be different on every render, causing unnecessary background re-renders.</p>
</li>
<li>
<p>When <code>useDeferredValue</code> receives a different value (compared with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is</code></a>), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there's another update to the <code>value</code>, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing.</p>
</li>
<li>
<p><code>useDeferredValue</code> is integrated with <a href="/reference/react/Suspense"><code>&lt;Suspense&gt;</code>.</a> If the background update caused by a new value suspends the UI, the user will not see the fallback. They will keep seeing the old deferred value until the data loads.</p>
</li>
<li>
<p><code>useDeferredValue</code> does not by itself prevent extra network requests.</p>
</li>
<li>
<p>There is no fixed delay caused by <code>useDeferredValue</code> itself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. However, any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it.</p>
</li>
<li>
<p>The background re-render caused by <code>useDeferredValue</code> does not fire Effects until it's committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates.</p>
</li>
</ul>
<hr />
<h2 id="usage-usage"><a class="header" href="#usage-usage">Usage {/<em>usage</em>/}</a></h2>
<h3 id="showing-stale-content-while-fresh-content-is-loading-showing-stale-content-while-fresh-content-is-loading"><a class="header" href="#showing-stale-content-while-fresh-content-is-loading-showing-stale-content-while-fresh-content-is-loading">Showing stale content while fresh content is loading {/<em>showing-stale-content-while-fresh-content-is-loading</em>/}</a></h3>
<p>Call <code>useDeferredValue</code> at the top level of your component to defer updating some part of your UI.</p>
<pre><code class="language-js [[1  5  &quot;query&quot;]  [2  5  &quot;deferredQuery&quot;]]">import { useState, useDeferredValue } from 'react';

function SearchPage() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  // ...
}
</code></pre>
<p>During the initial render, the <CodeStep step={2}>deferred value</CodeStep> will be the same as the <CodeStep step={1}>value</CodeStep> you provided.</p>
<p>During updates, the <CodeStep step={2}>deferred value</CodeStep> will &quot;lag behind&quot; the latest <CodeStep step={1}>value</CodeStep>. In particular, React will first re-render <em>without</em> updating the deferred value, and then try to re-render with the newly received value in background.</p>
<p><strong>Let's walk through an example to see when this is useful.</strong></p>
<Note>
<p>This example assumes you use one of Suspense-enabled data sources:</p>
<ul>
<li>Data fetching with Suspense-enabled frameworks like <a href="https://relay.dev/docs/guided-tour/rendering/loading-states/">Relay</a> and <a href="https://nextjs.org/docs/advanced-features/react-18">Next.js</a></li>
<li>Lazy-loading component code with <a href="/reference/react/lazy"><code>lazy</code></a></li>
</ul>
<p><a href="/reference/react/Suspense">Learn more about Suspense and its limitations.</a></p>
</Note>
<p>In this example, the <code>SearchResults</code> component <a href="/reference/react/Suspense#displaying-a-fallback-while-content-is-loading">suspends</a> while fetching the search results. Try typing <code>&quot;a&quot;</code>, waiting for the results, and then editing it to <code>&quot;ab&quot;</code>. The results for <code>&quot;a&quot;</code> will get replaced by the loading fallback.</p>
<Sandpack>
<pre><code class="language-json package.json hidden">{
  &quot;dependencies&quot;: {
    &quot;react&quot;: &quot;experimental&quot;,
    &quot;react-dom&quot;: &quot;experimental&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;
  }
}
</code></pre>
<pre><code class="language-js App.js">import { Suspense, useState } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  return (
    &lt;&gt;
      &lt;label&gt;
        Search albums:
        &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      &lt;/label&gt;
      &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt;
        &lt;SearchResults query={query} /&gt;
      &lt;/Suspense&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-js SearchResults.js hidden">import { fetchData } from './data.js';

// Note: this component is written using an experimental API
// that's not yet available in stable versions of React.

// For a realistic example you can follow today, try a framework
// that's integrated with Suspense, like Relay or Next.js.

export default function SearchResults({ query }) {
  if (query === '') {
    return null;
  }
  const albums = use(fetchData(`/search?q=${query}`));
  if (albums.length === 0) {
    return &lt;p&gt;No matches for &lt;i&gt;&quot;{query}&quot;&lt;/i&gt;&lt;/p&gt;;
  }
  return (
    &lt;ul&gt;
      {albums.map(album =&gt; (
        &lt;li key={album.id}&gt;
          {album.title} ({album.year})
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// This is a workaround for a bug to get the demo running.
// TODO: replace with real implementation when the bug is fixed.
function use(promise) {
  if (promise.status === 'fulfilled') {
    return promise.value;
  } else if (promise.status === 'rejected') {
    throw promise.reason;
  } else if (promise.status === 'pending') {
    throw promise;
  } else {
    promise.status = 'pending';
    promise.then(
      result =&gt; {
        promise.status = 'fulfilled';
        promise.value = result;
      },
      reason =&gt; {
        promise.status = 'rejected';
        promise.reason = reason;
      },      
    );
    throw promise;
  }
}
</code></pre>
<pre><code class="language-js data.js hidden">// Note: the way you would do data fething depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url.startsWith('/search?q=')) {
    return await getSearchResults(url.slice('/search?q='.length));
  } else {
    throw Error('Not implemented');
  }
}

async function getSearchResults(query) {
  // Add a fake delay to make waiting noticeable.
  await new Promise(resolve =&gt; {
    setTimeout(resolve, 500);
  });

  const allAlbums = [{
    id: 13,
    title: 'Let It Be',
    year: 1970
  }, {
    id: 12,
    title: 'Abbey Road',
    year: 1969
  }, {
    id: 11,
    title: 'Yellow Submarine',
    year: 1969
  }, {
    id: 10,
    title: 'The Beatles',
    year: 1968
  }, {
    id: 9,
    title: 'Magical Mystery Tour',
    year: 1967
  }, {
    id: 8,
    title: 'Sgt. Pepper\'s Lonely Hearts Club Band',
    year: 1967
  }, {
    id: 7,
    title: 'Revolver',
    year: 1966
  }, {
    id: 6,
    title: 'Rubber Soul',
    year: 1965
  }, {
    id: 5,
    title: 'Help!',
    year: 1965
  }, {
    id: 4,
    title: 'Beatles For Sale',
    year: 1964
  }, {
    id: 3,
    title: 'A Hard Day\'s Night',
    year: 1964
  }, {
    id: 2,
    title: 'With The Beatles',
    year: 1963
  }, {
    id: 1,
    title: 'Please Please Me',
    year: 1963
  }];

  const lowerQuery = query.trim().toLowerCase();
  return allAlbums.filter(album =&gt; {
    const lowerTitle = album.title.toLowerCase();
    return (
      lowerTitle.startsWith(lowerQuery) ||
      lowerTitle.indexOf(' ' + lowerQuery) !== -1
    )
  });
}
</code></pre>
<pre><code class="language-css">input { margin: 10px; }
</code></pre>
</Sandpack>
<p>A common alternative UI pattern is to <em>defer</em> updating the list of results and to keep showing the previous results until the new results are ready. The <code>useDeferredValue</code> Hook lets you pass a deferred version of the query down: </p>
<pre><code class="language-js {3 11}">export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  return (
    &lt;&gt;
      &lt;label&gt;
        Search albums:
        &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      &lt;/label&gt;
      &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt;
        &lt;SearchResults query={deferredQuery} /&gt;
      &lt;/Suspense&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>The <code>query</code> will update immediately, so the input will display the new value. However, the <code>deferredQuery</code> will keep its previous value until the data has loaded, so <code>SearchResults</code> will show the stale results for a bit.</p>
<p>Enter <code>&quot;a&quot;</code> in the example below, wait for the results to load, and then edit the input to <code>&quot;ab&quot;</code>. Notice how instead of the Suspense fallback, you now see the stale result list until the new results have loaded:</p>
<Sandpack>
<pre><code class="language-json package.json hidden">{
  &quot;dependencies&quot;: {
    &quot;react&quot;: &quot;experimental&quot;,
    &quot;react-dom&quot;: &quot;experimental&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;
  }
}
</code></pre>
<pre><code class="language-js App.js">import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  return (
    &lt;&gt;
      &lt;label&gt;
        Search albums:
        &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      &lt;/label&gt;
      &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt;
        &lt;SearchResults query={deferredQuery} /&gt;
      &lt;/Suspense&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-js SearchResults.js hidden">import { fetchData } from './data.js';

// Note: this component is written using an experimental API
// that's not yet available in stable versions of React.

// For a realistic example you can follow today, try a framework
// that's integrated with Suspense, like Relay or Next.js.

export default function SearchResults({ query }) {
  if (query === '') {
    return null;
  }
  const albums = use(fetchData(`/search?q=${query}`));
  if (albums.length === 0) {
    return &lt;p&gt;No matches for &lt;i&gt;&quot;{query}&quot;&lt;/i&gt;&lt;/p&gt;;
  }
  return (
    &lt;ul&gt;
      {albums.map(album =&gt; (
        &lt;li key={album.id}&gt;
          {album.title} ({album.year})
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// This is a workaround for a bug to get the demo running.
// TODO: replace with real implementation when the bug is fixed.
function use(promise) {
  if (promise.status === 'fulfilled') {
    return promise.value;
  } else if (promise.status === 'rejected') {
    throw promise.reason;
  } else if (promise.status === 'pending') {
    throw promise;
  } else {
    promise.status = 'pending';
    promise.then(
      result =&gt; {
        promise.status = 'fulfilled';
        promise.value = result;
      },
      reason =&gt; {
        promise.status = 'rejected';
        promise.reason = reason;
      },      
    );
    throw promise;
  }
}
</code></pre>
<pre><code class="language-js data.js hidden">// Note: the way you would do data fething depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url.startsWith('/search?q=')) {
    return await getSearchResults(url.slice('/search?q='.length));
  } else {
    throw Error('Not implemented');
  }
}

async function getSearchResults(query) {
  // Add a fake delay to make waiting noticeable.
  await new Promise(resolve =&gt; {
    setTimeout(resolve, 500);
  });

  const allAlbums = [{
    id: 13,
    title: 'Let It Be',
    year: 1970
  }, {
    id: 12,
    title: 'Abbey Road',
    year: 1969
  }, {
    id: 11,
    title: 'Yellow Submarine',
    year: 1969
  }, {
    id: 10,
    title: 'The Beatles',
    year: 1968
  }, {
    id: 9,
    title: 'Magical Mystery Tour',
    year: 1967
  }, {
    id: 8,
    title: 'Sgt. Pepper\'s Lonely Hearts Club Band',
    year: 1967
  }, {
    id: 7,
    title: 'Revolver',
    year: 1966
  }, {
    id: 6,
    title: 'Rubber Soul',
    year: 1965
  }, {
    id: 5,
    title: 'Help!',
    year: 1965
  }, {
    id: 4,
    title: 'Beatles For Sale',
    year: 1964
  }, {
    id: 3,
    title: 'A Hard Day\'s Night',
    year: 1964
  }, {
    id: 2,
    title: 'With The Beatles',
    year: 1963
  }, {
    id: 1,
    title: 'Please Please Me',
    year: 1963
  }];

  const lowerQuery = query.trim().toLowerCase();
  return allAlbums.filter(album =&gt; {
    const lowerTitle = album.title.toLowerCase();
    return (
      lowerTitle.startsWith(lowerQuery) ||
      lowerTitle.indexOf(' ' + lowerQuery) !== -1
    )
  });
}
</code></pre>
<pre><code class="language-css">input { margin: 10px; }
</code></pre>
</Sandpack>
<DeepDive>
<h4 id="how-does-deferring-a-value-work-under-the-hood-how-does-deferring-a-value-work-under-the-hood"><a class="header" href="#how-does-deferring-a-value-work-under-the-hood-how-does-deferring-a-value-work-under-the-hood">How does deferring a value work under the hood? {/<em>how-does-deferring-a-value-work-under-the-hood</em>/}</a></h4>
<p>You can think of it as happening in two steps:</p>
<ol>
<li>
<p><strong>First, React re-renders with the new <code>query</code> (<code>&quot;ab&quot;</code>) but with the old <code>deferredQuery</code> (still <code>&quot;a&quot;)</code>.</strong> The <code>deferredQuery</code> value, which you pass to the result list, is <em>deferred:</em> it &quot;lags behind&quot; the <code>query</code> value.</p>
</li>
<li>
<p><strong>In background, React tries to re-render with <em>both</em> <code>query</code> and <code>deferredQuery</code> updated to <code>&quot;ab&quot;</code>.</strong> If this re-render completes, React will show it on the screen. However, if it suspends (the results for <code>&quot;ab&quot;</code> have not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded. The user will keep seeing the stale deferred value until the data is ready.</p>
</li>
</ol>
<p>The deferred &quot;background&quot; rendering is interruptible. For example, if you type into the input again, React will abandon it and restart with the new value. React will always use the latest provided value.</p>
<p>Note that there is still a network request per each keystroke. What's being deferred here is displaying results (until they're ready), not the network requests themselves. Even if the user continues typing, responses for each keystroke get cached, so pressing Backspace is instant and doesn't fetch again.</p>
</DeepDive>
<hr />
<h3 id="indicating-that-the-content-is-stale-indicating-that-the-content-is-stale"><a class="header" href="#indicating-that-the-content-is-stale-indicating-that-the-content-is-stale">Indicating that the content is stale {/<em>indicating-that-the-content-is-stale</em>/}</a></h3>
<p>In the example above, there is no indication that the result list for the latest query is still loading. This can be confusing to the user if the new results take a while to load. To make it more obvious to the user that the result list does not match the latest query, you can add a visual indication when the stale result list is displayed:</p>
<pre><code class="language-js {2}">&lt;div style={{
  opacity: query !== deferredQuery ? 0.5 : 1,
}}&gt;
  &lt;SearchResults query={deferredQuery} /&gt;
&lt;/div&gt;
</code></pre>
<p>With this change, as soon as you start typing, the stale result list gets slightly dimmed until the new result list loads. You can also add a CSS transition to delay dimming so that it feels gradual, like in the example below:</p>
<Sandpack>
<pre><code class="language-json package.json hidden">{
  &quot;dependencies&quot;: {
    &quot;react&quot;: &quot;experimental&quot;,
    &quot;react-dom&quot;: &quot;experimental&quot;
  },
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;react-scripts start&quot;,
    &quot;build&quot;: &quot;react-scripts build&quot;,
    &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;,
    &quot;eject&quot;: &quot;react-scripts eject&quot;
  }
}
</code></pre>
<pre><code class="language-js App.js">import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  const isStale = query !== deferredQuery;
  return (
    &lt;&gt;
      &lt;label&gt;
        Search albums:
        &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;
      &lt;/label&gt;
      &lt;Suspense fallback={&lt;h2&gt;Loading...&lt;/h2&gt;}&gt;
        &lt;div style={{
          opacity: isStale ? 0.5 : 1,
          transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear'
        }}&gt;
          &lt;SearchResults query={deferredQuery} /&gt;
        &lt;/div&gt;
      &lt;/Suspense&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-js SearchResults.js hidden">import { fetchData } from './data.js';

// Note: this component is written using an experimental API
// that's not yet available in stable versions of React.

// For a realistic example you can follow today, try a framework
// that's integrated with Suspense, like Relay or Next.js.

export default function SearchResults({ query }) {
  if (query === '') {
    return null;
  }
  const albums = use(fetchData(`/search?q=${query}`));
  if (albums.length === 0) {
    return &lt;p&gt;No matches for &lt;i&gt;&quot;{query}&quot;&lt;/i&gt;&lt;/p&gt;;
  }
  return (
    &lt;ul&gt;
      {albums.map(album =&gt; (
        &lt;li key={album.id}&gt;
          {album.title} ({album.year})
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// This is a workaround for a bug to get the demo running.
// TODO: replace with real implementation when the bug is fixed.
function use(promise) {
  if (promise.status === 'fulfilled') {
    return promise.value;
  } else if (promise.status === 'rejected') {
    throw promise.reason;
  } else if (promise.status === 'pending') {
    throw promise;
  } else {
    promise.status = 'pending';
    promise.then(
      result =&gt; {
        promise.status = 'fulfilled';
        promise.value = result;
      },
      reason =&gt; {
        promise.status = 'rejected';
        promise.reason = reason;
      },      
    );
    throw promise;
  }
}
</code></pre>
<pre><code class="language-js data.js hidden">// Note: the way you would do data fething depends on
// the framework that you use together with Suspense.
// Normally, the caching logic would be inside a framework.

let cache = new Map();

export function fetchData(url) {
  if (!cache.has(url)) {
    cache.set(url, getData(url));
  }
  return cache.get(url);
}

async function getData(url) {
  if (url.startsWith('/search?q=')) {
    return await getSearchResults(url.slice('/search?q='.length));
  } else {
    throw Error('Not implemented');
  }
}

async function getSearchResults(query) {
  // Add a fake delay to make waiting noticeable.
  await new Promise(resolve =&gt; {
    setTimeout(resolve, 500);
  });

  const allAlbums = [{
    id: 13,
    title: 'Let It Be',
    year: 1970
  }, {
    id: 12,
    title: 'Abbey Road',
    year: 1969
  }, {
    id: 11,
    title: 'Yellow Submarine',
    year: 1969
  }, {
    id: 10,
    title: 'The Beatles',
    year: 1968
  }, {
    id: 9,
    title: 'Magical Mystery Tour',
    year: 1967
  }, {
    id: 8,
    title: 'Sgt. Pepper\'s Lonely Hearts Club Band',
    year: 1967
  }, {
    id: 7,
    title: 'Revolver',
    year: 1966
  }, {
    id: 6,
    title: 'Rubber Soul',
    year: 1965
  }, {
    id: 5,
    title: 'Help!',
    year: 1965
  }, {
    id: 4,
    title: 'Beatles For Sale',
    year: 1964
  }, {
    id: 3,
    title: 'A Hard Day\'s Night',
    year: 1964
  }, {
    id: 2,
    title: 'With The Beatles',
    year: 1963
  }, {
    id: 1,
    title: 'Please Please Me',
    year: 1963
  }];

  const lowerQuery = query.trim().toLowerCase();
  return allAlbums.filter(album =&gt; {
    const lowerTitle = album.title.toLowerCase();
    return (
      lowerTitle.startsWith(lowerQuery) ||
      lowerTitle.indexOf(' ' + lowerQuery) !== -1
    )
  });
}
</code></pre>
<pre><code class="language-css">input { margin: 10px; }
</code></pre>
</Sandpack>
<hr />
<h3 id="deferring-re-rendering-for-a-part-of-the-ui-deferring-re-rendering-for-a-part-of-the-ui"><a class="header" href="#deferring-re-rendering-for-a-part-of-the-ui-deferring-re-rendering-for-a-part-of-the-ui">Deferring re-rendering for a part of the UI {/<em>deferring-re-rendering-for-a-part-of-the-ui</em>/}</a></h3>
<p>You can also apply <code>useDeferredValue</code> as a performance optimization. It is useful when a part of your UI is slow to re-render, there's no easy way to optimize it, and you want to prevent it from blocking the rest of the UI.</p>
<p>Imagine you have a text field and a component (like a chart or a long list) that re-renders on every keystroke:</p>
<pre><code class="language-js">function App() {
  const [text, setText] = useState('');
  return (
    &lt;&gt;
      &lt;input value={text} onChange={e =&gt; setText(e.target.value)} /&gt;
      &lt;SlowList text={text} /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>First, optimize <code>SlowList</code> to skip re-rendering when its props are the same. To do this, <a href="/reference/react/memo#skipping-re-rendering-when-props-are-unchanged">wrap it in <code>memo</code>:</a></p>
<pre><code class="language-js {1 3}">const SlowList = memo(function SlowList({ text }) {
  // ...
});
</code></pre>
<p>However, this only helps if the <code>SlowList</code> props are <em>the same</em> as during the previous render. The problem you're facing now is that it's slow when they're <em>different,</em> and when you actually need to show different visual output.</p>
<p>Concretely, the main performance problem is that whenever you type into the input, the <code>SlowList</code> receives new props, and re-rendering its entire tree makes the typing feel janky. In this case, <code>useDeferredValue</code> lets you prioritize updating the input (which must be fast) over updating the result list (which is allowed to be slower):</p>
<pre><code class="language-js {3 7}">function App() {
  const [text, setText] = useState('');
  const deferredText = useDeferredValue(text);
  return (
    &lt;&gt;
      &lt;input value={text} onChange={e =&gt; setText(e.target.value)} /&gt;
      &lt;SlowList text={deferredText} /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>This does not make re-rendering of the <code>SlowList</code> faster. However, it tells React that re-rendering the list can be deprioritized so that it doesn't block the keystrokes. The list will &quot;lag behind&quot; the input and then &quot;catch up&quot;. Like before, React will attempt to update the list as soon as possible, but it will not block the user from typing again.</p>
<Recipes titleText="The difference between useDeferredValue and unoptimized re-rendering" titleId="examples">
<h4 id="deferred-re-rendering-of-the-list-deferred-re-rendering-of-the-list"><a class="header" href="#deferred-re-rendering-of-the-list-deferred-re-rendering-of-the-list">Deferred re-rendering of the list {/<em>deferred-re-rendering-of-the-list</em>/}</a></h4>
<p>In this example, each item in the <code>SlowList</code> component is <strong>artificially slowed down</strong> so that you can see how <code>useDeferredValue</code> lets you keep the input responsive. Type into the input and notice that typing feels snappy while the list &quot;lags behind&quot; it.</p>
<Sandpack>
<pre><code class="language-js">import { useState, useDeferredValue } from 'react';
import SlowList from './SlowList.js';

export default function App() {
  const [text, setText] = useState('');
  const deferredText = useDeferredValue(text);
  return (
    &lt;&gt;
      &lt;input value={text} onChange={e =&gt; setText(e.target.value)} /&gt;
      &lt;SlowList text={deferredText} /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-js SlowList.js">import { memo } from 'react';

const SlowList = memo(function SlowList({ text }) {
  // Log once. The actual slowdown is inside SlowItem.
  console.log('[ARTIFICIALLY SLOW] Rendering 250 &lt;SlowItem /&gt;');

  let items = [];
  for (let i = 0; i &lt; 250; i++) {
    items.push(&lt;SlowItem key={i} text={text} /&gt;);
  }
  return (
    &lt;ul className=&quot;items&quot;&gt;
      {items}
    &lt;/ul&gt;
  );
});

function SlowItem({ text }) {
  let startTime = performance.now();
  while (performance.now() - startTime &lt; 1) {
    // Do nothing for 1 ms per item to emulate extremely slow code
  }

  return (
    &lt;li className=&quot;item&quot;&gt;
      Text: {text}
    &lt;/li&gt;
  )
}

export default SlowList;
</code></pre>
<pre><code class="language-css">.items {
  padding: 0;
}

.item {
  list-style: none;
  display: block;
  height: 40px;
  padding: 5px;
  margin-top: 10px;
  border-radius: 4px;
  border: 1px solid #aaa;
}
</code></pre>
</Sandpack>
<Solution />
<h4 id="unoptimized-re-rendering-of-the-list-unoptimized-re-rendering-of-the-list"><a class="header" href="#unoptimized-re-rendering-of-the-list-unoptimized-re-rendering-of-the-list">Unoptimized re-rendering of the list {/<em>unoptimized-re-rendering-of-the-list</em>/}</a></h4>
<p>In this example, each item in the <code>SlowList</code> component is <strong>artificially slowed down</strong>, but there is no <code>useDeferredValue</code>.</p>
<p>Notice how typing into the input feels very janky. This is because without <code>useDeferredValue</code>, each keystroke forces the entire list to re-render immediately in a non-interruptible way.</p>
<Sandpack>
<pre><code class="language-js">import { useState } from 'react';
import SlowList from './SlowList.js';

export default function App() {
  const [text, setText] = useState('');
  return (
    &lt;&gt;
      &lt;input value={text} onChange={e =&gt; setText(e.target.value)} /&gt;
      &lt;SlowList text={text} /&gt;
    &lt;/&gt;
  );
}
</code></pre>
<pre><code class="language-js SlowList.js">import { memo } from 'react';

const SlowList = memo(function SlowList({ text }) {
  // Log once. The actual slowdown is inside SlowItem.
  console.log('[ARTIFICIALLY SLOW] Rendering 250 &lt;SlowItem /&gt;');

  let items = [];
  for (let i = 0; i &lt; 250; i++) {
    items.push(&lt;SlowItem key={i} text={text} /&gt;);
  }
  return (
    &lt;ul className=&quot;items&quot;&gt;
      {items}
    &lt;/ul&gt;
  );
});

function SlowItem({ text }) {
  let startTime = performance.now();
  while (performance.now() - startTime &lt; 1) {
    // Do nothing for 1 ms per item to emulate extremely slow code
  }

  return (
    &lt;li className=&quot;item&quot;&gt;
      Text: {text}
    &lt;/li&gt;
  )
}

export default SlowList;
</code></pre>
<pre><code class="language-css">.items {
  padding: 0;
}

.item {
  list-style: none;
  display: block;
  height: 40px;
  padding: 5px;
  margin-top: 10px;
  border-radius: 4px;
  border: 1px solid #aaa;
}
</code></pre>
</Sandpack>
<Solution />
</Recipes>
<Pitfall>
<p>This optimization requires <code>SlowList</code> to be wrapped in <a href="/reference/react/memo"><code>memo</code>.</a> This is because whenever the <code>text</code> changes, React needs to be able to re-render the parent component quickly. During that re-render, <code>deferredText</code> still has its previous value, so <code>SlowList</code> is able to skip re-rendering (its props have not changed). Without <a href="/reference/react/memo"><code>memo</code>,</a> it would have to re-render anyway, defeating the point of the optimization.</p>
</Pitfall>
<DeepDive>
<h4 id="how-is-deferring-a-value-different-from-debouncing-and-throttling-how-is-deferring-a-value-different-from-debouncing-and-throttling"><a class="header" href="#how-is-deferring-a-value-different-from-debouncing-and-throttling-how-is-deferring-a-value-different-from-debouncing-and-throttling">How is deferring a value different from debouncing and throttling? {/<em>how-is-deferring-a-value-different-from-debouncing-and-throttling</em>/}</a></h4>
<p>There are two common optimization techniques you might have used before in this scenario:</p>
<ul>
<li><em>Debouncing</em> means you'd wait for the user to stop typing (e.g. for a second) before updating the list.</li>
<li><em>Throttling</em> means you'd update the list every once in a while (e.g. at most once a second).</li>
</ul>
<p>While these techniques are helpful in some cases, <code>useDeferredValue</code> is better suited to optimizing rendering because it is deeply integrated with React itself and adapts to the user's device.</p>
<p>Unlike debouncing or throttling, it doesn't require choosing any fixed delay. If the user's device is fast (e.g. powerful laptop), the deferred re-render would happen almost immediately and wouldn't be noticeable. If the user's device is slow, the list would &quot;lag behind&quot; the input proportionally to how slow the device is.</p>
<p>Also, unlike with debouncing or throttling, deferred re-renders done by <code>useDeferredValue</code> are interruptible by default. This means that if React is in the middle of re-rendering a large list, but the user makes another keystroke, React will abandon that re-render, handle the keystroke, and then start rendering in background again. By contrast, debouncing and throttling still produce a janky experience because they're <em>blocking:</em> they merely postpone the moment when rendering blocks the keystroke.</p>
<p>If the work you're optimizing doesn't happen during rendering, debouncing and throttling are still useful. For example, they can let you fire fewer network requests. You can also use these techniques together.</p>
</DeepDive>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../reference/react/useDebugValue.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../reference/react/useEffect.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../reference/react/useDebugValue.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../reference/react/useEffect.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
